/-
Copyright ¬© 2022 Heather Macbeth. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Heather Macbeth, Floris van Doorn
-/

import topology.vector_bundle.basic

/-!
# Direct sum of two vector bundles

If `E‚ÇÅ : B ‚Üí Type*` and `E‚ÇÇ : B ‚Üí Type*` define two topological vector bundles over `R` with fiber
models `F‚ÇÅ` and `F‚ÇÇ`, we define the bundle of direct sums `E‚ÇÅ √ó·µá E‚ÇÇ := Œª x, E‚ÇÅ x √ó E‚ÇÇ x`.
We can endow `E‚ÇÅ √ó·µá E‚ÇÇ` with a topological vector bundle structure:
`bundle.prod.topological_vector_bundle`.

A similar construction (which is yet to be formalized) can be done for the vector bundle of
continuous linear maps from `E‚ÇÅ x` to `E‚ÇÇ x` with fiber a type synonym
`vector_bundle_continuous_linear_map R F‚ÇÅ E‚ÇÅ F‚ÇÇ E‚ÇÇ x := (E‚ÇÅ x ‚ÜíL[R] E‚ÇÇ x)` (and with the
topology inherited from the norm-topology on `F‚ÇÅ ‚ÜíL[R] F‚ÇÇ`, without the need to define the strong
topology on continuous linear maps between general topological vector spaces).  Likewise for tensor
products of topological vector bundles, exterior algebras, and so on, where the topology can be
defined using a norm on the fiber model if this helps.

## Tags
Vector bundle
-/

noncomputable theory

open bundle set
open_locale classical

variables (R ùïú : Type*) {B : Type*} (F : Type*) (E : B ‚Üí Type*)

namespace topological_vector_bundle

section defs
variables (E‚ÇÅ : B ‚Üí Type*) (E‚ÇÇ : B ‚Üí Type*)
variables [topological_space (total_space E‚ÇÅ)] [topological_space (total_space E‚ÇÇ)]

/-- Equip the total space of the fibrewise product of two topological vector bundles `E‚ÇÅ`, `E‚ÇÇ` with
the induced topology from the diagonal embedding into `total_space E‚ÇÅ √ó total_space E‚ÇÇ`. -/
instance prod.topological_space :
  topological_space (total_space (E‚ÇÅ √ó·µá E‚ÇÇ)) :=
topological_space.induced
  (Œª p, ((‚ü®p.1, p.2.1‚ü© : total_space E‚ÇÅ), (‚ü®p.1, p.2.2‚ü© : total_space E‚ÇÇ)))
  (by apply_instance : topological_space (total_space E‚ÇÅ √ó total_space E‚ÇÇ))

/-- The diagonal map from the total space of the fibrewise product of two topological vector bundles
`E‚ÇÅ`, `E‚ÇÇ` into `total_space E‚ÇÅ √ó total_space E‚ÇÇ` is `inducing`. -/
lemma prod.inducing_diag : inducing
  (Œª p, (‚ü®p.1, p.2.1‚ü©, ‚ü®p.1, p.2.2‚ü©) :
    total_space (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Üí total_space E‚ÇÅ √ó total_space E‚ÇÇ) :=
‚ü®rfl‚ü©

end defs

variables [nondiscrete_normed_field R] [topological_space B]

variables (F‚ÇÅ : Type*) [normed_group F‚ÇÅ] [normed_space R F‚ÇÅ]
  (E‚ÇÅ : B ‚Üí Type*) [topological_space (total_space E‚ÇÅ)]
  [Œ† x, add_comm_monoid (E‚ÇÅ x)] [Œ† x, module R (E‚ÇÅ x)]

variables (F‚ÇÇ : Type*) [normed_group F‚ÇÇ] [normed_space R F‚ÇÇ]
  (E‚ÇÇ : B ‚Üí Type*) [topological_space (total_space E‚ÇÇ)]
  [Œ† x, add_comm_monoid (E‚ÇÇ x)] [Œ† x, module R (E‚ÇÇ x)]

namespace trivialization
variables (e‚ÇÅ : trivialization R F‚ÇÅ E‚ÇÅ) (e‚ÇÇ : trivialization R F‚ÇÇ E‚ÇÇ)
include e‚ÇÅ e‚ÇÇ
variables {R F‚ÇÅ E‚ÇÅ F‚ÇÇ E‚ÇÇ}

/-- Given trivializations `e‚ÇÅ`, `e‚ÇÇ` for vector bundles `E‚ÇÅ`, `E‚ÇÇ` over a base `B`, the forward
function for the construction `topological_vector_bundle.trivialization.prod`, the induced
trivialization for the direct sum of `E‚ÇÅ` and `E‚ÇÇ`. -/
def prod.to_fun' : total_space (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Üí B √ó (F‚ÇÅ √ó F‚ÇÇ) :=
Œª p, ‚ü®p.1, (e‚ÇÅ ‚ü®p.1, p.2.1‚ü©).2, (e‚ÇÇ ‚ü®p.1, p.2.2‚ü©).2‚ü©

variables {e‚ÇÅ e‚ÇÇ}

lemma prod.continuous_to_fun : continuous_on (prod.to_fun' e‚ÇÅ e‚ÇÇ)
  (@total_space.proj B (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Åª¬π' (e‚ÇÅ.base_set ‚à© e‚ÇÇ.base_set)) :=
begin
  let f‚ÇÅ : total_space (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Üí total_space E‚ÇÅ √ó total_space E‚ÇÇ :=
    Œª p, ((‚ü®p.1, p.2.1‚ü© : total_space E‚ÇÅ), (‚ü®p.1, p.2.2‚ü© : total_space E‚ÇÇ)),
  let f‚ÇÇ : total_space E‚ÇÅ √ó total_space E‚ÇÇ ‚Üí (B √ó F‚ÇÅ) √ó (B √ó F‚ÇÇ) := Œª p, ‚ü®e‚ÇÅ p.1, e‚ÇÇ p.2‚ü©,
  let f‚ÇÉ : (B √ó F‚ÇÅ) √ó (B √ó F‚ÇÇ) ‚Üí B √ó F‚ÇÅ √ó F‚ÇÇ := Œª p, ‚ü®p.1.1, p.1.2, p.2.2‚ü©,
  have hf‚ÇÅ : continuous f‚ÇÅ := (prod.inducing_diag E‚ÇÅ E‚ÇÇ).continuous,
  have hf‚ÇÇ : continuous_on f‚ÇÇ (e‚ÇÅ.source √óÀ¢ e‚ÇÇ.source) :=
    e‚ÇÅ.to_local_homeomorph.continuous_on.prod_map e‚ÇÇ.to_local_homeomorph.continuous_on,
  have hf‚ÇÉ : continuous f‚ÇÉ :=
    (continuous_fst.comp continuous_fst).prod_mk (continuous_snd.prod_map continuous_snd),
  refine ((hf‚ÇÉ.comp_continuous_on hf‚ÇÇ).comp hf‚ÇÅ.continuous_on _).congr _,
  { rw [e‚ÇÅ.source_eq, e‚ÇÇ.source_eq],
    exact maps_to_preimage _ _ },
  rintros ‚ü®b, v‚ÇÅ, v‚ÇÇ‚ü© ‚ü®hb‚ÇÅ, hb‚ÇÇ‚ü©,
  simp only [prod.to_fun', prod.mk.inj_iff, eq_self_iff_true, and_true],
  rw e‚ÇÅ.coe_fst,
  rw [e‚ÇÅ.source_eq, mem_preimage],
  exact hb‚ÇÅ,
end

variables (e‚ÇÅ e‚ÇÇ)

/-- Given trivializations `e‚ÇÅ`, `e‚ÇÇ` for vector bundles `E‚ÇÅ`, `E‚ÇÇ` over a base `B`, the inverse
function for the construction `topological_vector_bundle.trivialization.prod`, the induced
trivialization for the direct sum of `E‚ÇÅ` and `E‚ÇÇ`. -/
def prod.inv_fun' (p : B √ó (F‚ÇÅ √ó F‚ÇÇ)) : total_space (E‚ÇÅ √ó·µá E‚ÇÇ) :=
‚ü®p.1, e‚ÇÅ.symm p.1 p.2.1, e‚ÇÇ.symm p.1 p.2.2‚ü©

variables {e‚ÇÅ e‚ÇÇ}

lemma prod.left_inv {x : total_space (E‚ÇÅ √ó·µá E‚ÇÇ)}
  (h : x ‚àà @total_space.proj B (E‚ÇÅ √ó·µá E‚ÇÇ) ‚Åª¬π' (e‚ÇÅ.base_set ‚à© e‚ÇÇ.base_set)) :
  prod.inv_fun' e‚ÇÅ e‚ÇÇ (prod.to_fun' e‚ÇÅ e‚ÇÇ x) = x :=
begin
  obtain ‚ü®x, v‚ÇÅ, v‚ÇÇ‚ü© := x,
  obtain ‚ü®h‚ÇÅ : x ‚àà e‚ÇÅ.base_set, h‚ÇÇ : x ‚àà e‚ÇÇ.base_set‚ü© := h,
  simp only [prod.to_fun', prod.inv_fun', symm_apply_apply_mk, h‚ÇÅ, h‚ÇÇ]
end

lemma prod.right_inv {x : B √ó F‚ÇÅ √ó F‚ÇÇ}
  (h : x ‚àà (e‚ÇÅ.base_set ‚à© e‚ÇÇ.base_set) √óÀ¢ (univ : set (F‚ÇÅ √ó F‚ÇÇ))) :
  prod.to_fun' e‚ÇÅ e‚ÇÇ (prod.inv_fun' e‚ÇÅ e‚ÇÇ x) = x :=
begin
  obtain ‚ü®x, w‚ÇÅ, w‚ÇÇ‚ü© := x,
  obtain ‚ü®‚ü®h‚ÇÅ : x ‚àà e‚ÇÅ.base_set, h‚ÇÇ : x ‚àà e‚ÇÇ.base_set‚ü©, -‚ü© := h,
  simp only [prod.to_fun', prod.inv_fun', apply_mk_symm, h‚ÇÅ, h‚ÇÇ]
end

lemma prod.continuous_inv_fun :
  continuous_on (prod.inv_fun' e‚ÇÅ e‚ÇÇ) ((e‚ÇÅ.base_set ‚à© e‚ÇÇ.base_set) √óÀ¢ (univ : set (F‚ÇÅ √ó F‚ÇÇ))) :=
begin
  rw (prod.inducing_diag E‚ÇÅ E‚ÇÇ).continuous_on_iff,
  have H‚ÇÅ : continuous (Œª p : B √ó F‚ÇÅ √ó F‚ÇÇ, ((p.1, p.2.1), (p.1, p.2.2))) :=
    (continuous_id.prod_map continuous_fst).prod_mk (continuous_id.prod_map continuous_snd),
  refine (e‚ÇÅ.continuous_on_symm.prod_map e‚ÇÇ.continuous_on_symm).comp H‚ÇÅ.continuous_on _,
  exact Œª x h, ‚ü®‚ü®h.1.1, mem_univ _‚ü©, ‚ü®h.1.2, mem_univ _‚ü©‚ü©
end

variables (e‚ÇÅ e‚ÇÇ)
variables [Œ† x : B, topological_space (E‚ÇÅ x)] [Œ† x : B, topological_space (E‚ÇÇ x)]
  [topological_vector_bundle R F‚ÇÅ E‚ÇÅ] [topological_vector_bundle R F‚ÇÇ E‚ÇÇ]

/-- Given trivializations `e‚ÇÅ`, `e‚ÇÇ` for vector bundles `E‚ÇÅ`, `E‚ÇÇ` over a base `B`, the induced
trivialization for the direct sum of `E‚ÇÅ` and `E‚ÇÇ`, whose base set is `e‚ÇÅ.base_set ‚à© e‚ÇÇ.base_set`.
-/
@[nolint unused_arguments]
def prod : trivialization R (F‚ÇÅ √ó F‚ÇÇ) (E‚ÇÅ √ó·µá E‚ÇÇ) :=
{ to_fun := prod.to_fun' e‚ÇÅ e‚ÇÇ,
  inv_fun := prod.inv_fun' e‚ÇÅ e‚ÇÇ,
  source := (@total_space.proj B (E‚ÇÅ √ó·µá E‚ÇÇ)) ‚Åª¬π' (e‚ÇÅ.base_set ‚à© e‚ÇÇ.base_set),
  target := (e‚ÇÅ.base_set ‚à© e‚ÇÇ.base_set) √óÀ¢ (set.univ : set (F‚ÇÅ √ó F‚ÇÇ)),
  map_source' := Œª x h, ‚ü®h, set.mem_univ _‚ü©,
  map_target' := Œª x h, h.1,
  left_inv' := Œª x, prod.left_inv,
  right_inv' := Œª x, prod.right_inv,
  open_source := begin
    refine (e‚ÇÅ.open_base_set.inter e‚ÇÇ.open_base_set).preimage _,
    have : continuous (@total_space.proj B E‚ÇÅ) := continuous_proj R B F‚ÇÅ,
    exact this.comp (prod.inducing_diag E‚ÇÅ E‚ÇÇ).continuous.fst,
  end,
  open_target := (e‚ÇÅ.open_base_set.inter e‚ÇÇ.open_base_set).prod is_open_univ,
  continuous_to_fun := prod.continuous_to_fun,
  continuous_inv_fun := prod.continuous_inv_fun,
  base_set := e‚ÇÅ.base_set ‚à© e‚ÇÇ.base_set,
  open_base_set := e‚ÇÅ.open_base_set.inter e‚ÇÇ.open_base_set,
  source_eq := rfl,
  target_eq := rfl,
  proj_to_fun := Œª x h, rfl,
  linear' := Œª x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, (((e‚ÇÅ.linear h‚ÇÅ).mk' _).prod_map ((e‚ÇÇ.linear h‚ÇÇ).mk' _)).is_linear }

@[simp] lemma base_set_prod : (prod e‚ÇÅ e‚ÇÇ).base_set = e‚ÇÅ.base_set ‚à© e‚ÇÇ.base_set :=
rfl

variables {e‚ÇÅ e‚ÇÇ}

lemma prod_apply {x : B} (hx‚ÇÅ : x ‚àà e‚ÇÅ.base_set) (hx‚ÇÇ : x ‚àà e‚ÇÇ.base_set) (v‚ÇÅ : E‚ÇÅ x)
  (v‚ÇÇ : E‚ÇÇ x) :
  prod e‚ÇÅ e‚ÇÇ ‚ü®x, (v‚ÇÅ, v‚ÇÇ)‚ü©
  = ‚ü®x, e‚ÇÅ.continuous_linear_equiv_at x hx‚ÇÅ v‚ÇÅ, e‚ÇÇ.continuous_linear_equiv_at x hx‚ÇÇ v‚ÇÇ‚ü© :=
rfl

lemma prod_symm_apply (x : B) (w‚ÇÅ : F‚ÇÅ) (w‚ÇÇ : F‚ÇÇ) : (prod e‚ÇÅ e‚ÇÇ).to_local_equiv.symm (x, w‚ÇÅ, w‚ÇÇ)
  = ‚ü®x, e‚ÇÅ.symm x w‚ÇÅ, e‚ÇÇ.symm x w‚ÇÇ‚ü© :=
rfl

end trivialization

open trivialization

variables [Œ† x : B, topological_space (E‚ÇÅ x)] [Œ† x : B, topological_space (E‚ÇÇ x)]
  [topological_vector_bundle R F‚ÇÅ E‚ÇÅ] [topological_vector_bundle R F‚ÇÇ E‚ÇÇ]

/-- The product of two vector bundles is a vector bundle. -/
instance _root_.bundle.prod.topological_vector_bundle :
  topological_vector_bundle R (F‚ÇÅ √ó F‚ÇÇ) (E‚ÇÅ √ó·µá E‚ÇÇ) :=
{ total_space_mk_inducing := Œª b,
  begin
    rw (prod.inducing_diag E‚ÇÅ E‚ÇÇ).inducing_iff,
    exact (total_space_mk_inducing R F‚ÇÅ E‚ÇÅ b).prod_mk (total_space_mk_inducing R F‚ÇÇ E‚ÇÇ b),
  end,
  trivialization_atlas := (Œª (p : trivialization R F‚ÇÅ E‚ÇÅ √ó trivialization R F‚ÇÇ E‚ÇÇ), p.1.prod p.2) ''
    (trivialization_atlas R F‚ÇÅ E‚ÇÅ √óÀ¢ trivialization_atlas R F‚ÇÇ E‚ÇÇ),
  trivialization_at := Œª b, (trivialization_at R F‚ÇÅ E‚ÇÅ b).prod (trivialization_at R F‚ÇÇ E‚ÇÇ b),
  mem_base_set_trivialization_at :=
    Œª b, ‚ü®mem_base_set_trivialization_at R F‚ÇÅ E‚ÇÅ b, mem_base_set_trivialization_at R F‚ÇÇ E‚ÇÇ b‚ü©,
  trivialization_mem_atlas := Œª b,
    ‚ü®(_, _), ‚ü®trivialization_mem_atlas R F‚ÇÅ E‚ÇÅ b, trivialization_mem_atlas R F‚ÇÇ E‚ÇÇ b‚ü©, rfl‚ü©,
  continuous_on_coord_change := begin
    rintros _ ‚ü®‚ü®e‚ÇÅ, e‚ÇÇ‚ü©, ‚ü®he‚ÇÅ, he‚ÇÇ‚ü©, rfl‚ü© _ ‚ü®‚ü®e‚ÇÅ', e‚ÇÇ'‚ü©, ‚ü®he‚ÇÅ', he‚ÇÇ'‚ü©, rfl‚ü©,
    have := continuous_on_coord_change e‚ÇÅ he‚ÇÅ e‚ÇÅ' he‚ÇÅ',
    have := continuous_on_coord_change e‚ÇÇ he‚ÇÇ e‚ÇÇ' he‚ÇÇ',
    refine (((continuous_on_coord_change e‚ÇÅ he‚ÇÅ e‚ÇÅ' he‚ÇÅ').mono _).prod_mapL R
      ((continuous_on_coord_change e‚ÇÇ he‚ÇÇ e‚ÇÇ' he‚ÇÇ').mono _)).congr _;
    dsimp only [base_set_prod] with mfld_simps,
    { mfld_set_tac },
    { mfld_set_tac },
    { rintro b hb,
      rw [continuous_linear_map.ext_iff],
      rintro ‚ü®v‚ÇÅ, v‚ÇÇ‚ü©,
      show (e‚ÇÅ.prod e‚ÇÇ).coord_change (e‚ÇÅ'.prod e‚ÇÇ') b (v‚ÇÅ, v‚ÇÇ) =
        (e‚ÇÅ.coord_change e‚ÇÅ' b v‚ÇÅ, e‚ÇÇ.coord_change e‚ÇÇ' b v‚ÇÇ),
      rw [e‚ÇÅ.coord_change_apply e‚ÇÅ', e‚ÇÇ.coord_change_apply e‚ÇÇ', (e‚ÇÅ.prod e‚ÇÇ).coord_change_apply'],
      exacts [rfl, hb, ‚ü®hb.1.2, hb.2.2‚ü©, ‚ü®hb.1.1, hb.2.1‚ü©] }
  end }

variables {R F‚ÇÅ E‚ÇÅ F‚ÇÇ E‚ÇÇ}

@[simp] lemma trivialization.continuous_linear_equiv_at_prod {e‚ÇÅ : trivialization R F‚ÇÅ E‚ÇÅ}
  {e‚ÇÇ : trivialization R F‚ÇÇ E‚ÇÇ} {x : B} (hx‚ÇÅ : x ‚àà e‚ÇÅ.base_set) (hx‚ÇÇ : x ‚àà e‚ÇÇ.base_set) :
  (e‚ÇÅ.prod e‚ÇÇ).continuous_linear_equiv_at x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©
  = (e‚ÇÅ.continuous_linear_equiv_at x hx‚ÇÅ).prod (e‚ÇÇ.continuous_linear_equiv_at x hx‚ÇÇ) :=
begin
  ext1,
  funext v,
  obtain ‚ü®v‚ÇÅ, v‚ÇÇ‚ü© := v,
  rw [(e‚ÇÅ.prod e‚ÇÇ).continuous_linear_equiv_at_apply, trivialization.prod],
  exact (congr_arg prod.snd (prod_apply hx‚ÇÅ hx‚ÇÇ v‚ÇÅ v‚ÇÇ) : _)
end

end topological_vector_bundle
