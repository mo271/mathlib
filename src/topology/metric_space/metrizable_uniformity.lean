import topology.metric_space.basic

/-!
-/

open set function metric list filter
open_locale nnreal filter uniformity

variables {X : Type*}

namespace pseudo_metric_space

noncomputable def of_prenndist (d : X ‚Üí X ‚Üí ‚Ñù‚â•0) (dist_self : ‚àÄ x, d x x = 0)
  (dist_comm : ‚àÄ x y, d x y = d y x) :
  pseudo_metric_space X :=
{ dist := Œª x y, ‚Üë(‚®Ö l : list X, ((x :: l).zip_with d (l ++ [y])).sum : ‚Ñù‚â•0),
  dist_self := Œª x, (nnreal.coe_eq_zero _).2 $ nonpos_iff_eq_zero.1 $
    (cinfi_le (order_bot.bdd_below _) []).trans_eq $ by simp [dist_self],
  dist_comm := Œª x y, nnreal.coe_eq.2 $
    begin
      rw [‚Üê reverse_surjective.infi_comp],
      refine congr_arg infi (funext $ Œª l, _),
      rw [‚Üê sum_reverse, zip_with_distrib_reverse, reverse_append, reverse_reverse,
        reverse_singleton, singleton_append, reverse_cons, reverse_reverse,
        zip_with_comm _ dist_comm],
      simp
    end,
  dist_triangle := Œª x y z,
    begin
      rw [‚Üê nnreal.coe_add, nnreal.coe_le_coe],
      refine nnreal.le_infi_add_infi (Œª lxy lyz, _),
      calc (‚®Ö l, (zip_with d (x :: l) (l ++ [z])).sum) ‚â§
        (zip_with d (x :: (lxy ++ y :: lyz)) ((lxy ++ y :: lyz) ++ [z])).sum :
        cinfi_le (order_bot.bdd_below _) (lxy ++ y :: lyz)
      ... = (zip_with d (x :: lxy) (lxy ++ [y])).sum + (zip_with d (y :: lyz) (lyz ++ [z])).sum : _,
      rw [‚Üê sum_append, ‚Üê zip_with_append, cons_append, ‚Üê @singleton_append _ y, append_assoc,
        append_assoc, append_assoc],
      rw [length_cons, length_append, length_singleton]
    end }

lemma dist_of_prenndist_le (d : X ‚Üí X ‚Üí ‚Ñù‚â•0) (dist_self : ‚àÄ x, d x x = 0)
  (dist_comm : ‚àÄ x y, d x y = d y x) (x y : X) :
  @dist X (@pseudo_metric_space.to_has_dist X
    (pseudo_metric_space.of_prenndist d dist_self dist_comm)) x y ‚â§ d x y :=
nnreal.coe_le_coe.2 $ (cinfi_le (order_bot.bdd_below _) []).trans_eq $ by simp

lemma le_two_mul_dist_of_prenndist (d : X ‚Üí X ‚Üí ‚Ñù‚â•0) (dist_self : ‚àÄ x, d x x = 0)
  (dist_comm : ‚àÄ x y, d x y = d y x)
  (hd : ‚àÄ x‚ÇÅ x‚ÇÇ x‚ÇÉ x‚ÇÑ, d x‚ÇÅ x‚ÇÑ ‚â§ 2 * max (d x‚ÇÅ x‚ÇÇ) (max (d x‚ÇÇ x‚ÇÉ) (d x‚ÇÉ x‚ÇÑ))) (x y : X) :
  ‚Üë(d x y) ‚â§ 2 * @dist X (@pseudo_metric_space.to_has_dist X
    (pseudo_metric_space.of_prenndist d dist_self dist_comm)) x y :=
begin
  erw [‚Üê div_le_iff' (@two_pos ‚Ñù _ _), ‚Üê nnreal.coe_two, ‚Üê nnreal.coe_div, nnreal.coe_le_coe],
  refine le_cinfi (Œª l, nnreal.div_le_of_le_mul' _),
  have hd‚ÇÄ_trans : transitive (Œª x y, d x y = 0),
  { intros a b c hab hbc,
    rw ‚Üê nonpos_iff_eq_zero,
    simpa [hab, hbc, dist_self] using hd a b c c },
  haveI : is_trans X (Œª x y, d x y = 0) := ‚ü®hd‚ÇÄ_trans‚ü©,
  induction hn : length l using nat.strong_induction_on with n ihn generalizing x y l,
  simp only at ihn, subst n,
  set L := zip_with d (x :: l) (l ++ [y]),
  have hL_len : length L = length l + 1, by simp,
  cases eq_or_ne (d x y) 0 with hd‚ÇÄ hd‚ÇÄ, { simp only [hd‚ÇÄ, zero_le] },
  suffices : ‚àÉ z z' : X, d x z ‚â§ L.sum ‚àß d z z' ‚â§ L.sum ‚àß d z' y ‚â§ L.sum,
  { rcases this with ‚ü®z, z', hxz, hzz', hz'y‚ü©,
    exact (hd x z z' y).trans (mul_le_mul_left' (max_le hxz (max_le hzz' hz'y)) _) },
  set s : set ‚Ñï := {m : ‚Ñï | 2 * (take m L).sum ‚â§ L.sum},
  have hs‚ÇÄ : 0 ‚àà s, by simp [s],
  have hsne : s.nonempty, from ‚ü®0, hs‚ÇÄ‚ü©,
  obtain ‚ü®M, hMl, hMs‚ü© : ‚àÉ M ‚â§ length l, is_greatest s M,
  { have hs_ub : length l ‚àà upper_bounds s,
    { intros m hm,
      rw [‚Üê not_lt, nat.lt_iff_add_one_le, ‚Üê hL_len],
      intro hLm,
      rw [mem_set_of_eq, take_all_of_le hLm, two_mul, add_le_iff_nonpos_left, nonpos_iff_eq_zero,
        sum_eq_zero_iff, ‚Üê all‚ÇÇ_iff_forall, all‚ÇÇ_zip_with, ‚Üê chain_append_singleton_iff_forall‚ÇÇ]
        at hm; [skip, by simp],
      exact hd‚ÇÄ (hm.rel (mem_append.2 $ or.inr $ mem_singleton_self _)) },
    have hs_bdd : bdd_above s, from ‚ü®length l, hs_ub‚ü©,
    exact ‚ü®Sup s, cSup_le hsne hs_ub, ‚ü®nat.Sup_mem hsne hs_bdd, Œª k, le_cSup hs_bdd‚ü©‚ü© },
  have hM_lt : M < length L, by rwa [hL_len, nat.lt_succ_iff],
  have hM_ltx : M < length (x :: l), from lt_length_left_of_zip_with hM_lt,
  have hM_lty : M < length (l ++ [y]), from lt_length_right_of_zip_with hM_lt,
  refine ‚ü®(x :: l).nth_le M hM_ltx, (l ++ [y]).nth_le M hM_lty, _, _, _‚ü©,
  { cases M, { simp [dist_self] },
    rw nat.succ_le_iff at hMl,
    have hMl' : length (take M l) = M, from (length_take _ _).trans (min_eq_left hMl.le),
    simp only [nth_le],
    refine (ihn _ hMl _ _ _ hMl').trans _,
    convert hMs.1.out,
    rw [zip_with_distrib_take, take, take_succ, nth_append hMl, nth_le_nth hMl,
      ‚Üê option.coe_def, option.to_list_some, take_append_of_le_length hMl.le],
    refl },
  { refine single_le_sum (Œª x hx, zero_le x) _ (mem_iff_nth_le.2 ‚ü®M, hM_lt, _‚ü©),
    apply nth_le_zip_with },
  { rcases hMl.eq_or_lt with rfl|hMl,
    { simp only [nth_le_append_right le_rfl, sub_self, nth_le_singleton, dist_self, zero_le] },
    rw [nth_le_append _ hMl],
    have hlen : length (drop (M + 1) l) = length l - (M + 1), from length_drop _ _,
    have hlen_lt : length l - (M + 1) < length l, from nat.sub_lt_of_pos_le _ _ M.succ_pos hMl,
    refine (ihn _ hlen_lt _ y _ hlen).trans _,
    rw [cons_nth_le_drop_succ],
    have hMs' : L.sum ‚â§ 2 * (L.take (M + 1)).sum,
      from not_lt.1 (Œª h, (hMs.2 h.le).not_lt M.lt_succ_self),
    rw [‚Üê sum_take_add_sum_drop L (M + 1), two_mul, add_le_add_iff_left,
      ‚Üê add_le_add_iff_right, sum_take_add_sum_drop, ‚Üê two_mul] at hMs',
    convert hMs',
    rwa [zip_with_distrib_drop, drop, drop_append_of_le_length] }
end

end pseudo_metric_space

protected lemma uniform_space.metrizable_uniformity (X : Type*) [uniform_space X]
  [is_countably_generated (ùì§ X)] :
  ‚àÉ I : pseudo_metric_space X, I.to_uniform_space = ‚Äπ_‚Ä∫ :=
begin
  classical,
  obtain ‚ü®U, hU_symm, hU_comp, hB‚ü© : ‚àÉ U : ‚Ñï ‚Üí set (X √ó X), (‚àÄ n, symmetric_rel (U n)) ‚àß
    (‚àÄ ‚¶Ém n‚¶Ñ, m < n ‚Üí (U n ‚óã U n) ‚óã (U n ‚óã U n) ‚äÜ U m) ‚àß (ùì§ X).has_antitone_basis U,
  { rcases uniform_space.has_seq_basis X with ‚ü®V, hB, hV_symm‚ü©,
    rcases hB.subbasis_with_rel (Œª m, hB.tendsto_small_sets.eventually
      (eventually_uniformity_iterate_comp_subset (hB.mem m) 2)) with ‚ü®œÜ, hœÜ_mono, hœÜ_comp, hœÜB‚ü©,
    exact ‚ü®V ‚àò œÜ, Œª n, hV_symm _, hœÜ_comp, hœÜB‚ü© },
  letI := uniform_space.separation_setoid X,
  set d : X ‚Üí X ‚Üí ‚Ñù‚â•0 := Œª x y, if h : ‚àÉ n, (x, y) ‚àâ U n then (1 / 2) ^ nat.find h else 0,
  have hd‚ÇÄ : ‚àÄ {x y}, d x y = 0 ‚Üî x ‚âà y,
  { intros x y, dsimp only [d],
    refine iff.trans _ hB.to_has_basis.mem_separation_rel.symm,
    simp only [true_implies_iff],
    split_ifs with h,
    { rw [‚Üê not_forall] at h, simp [h, pow_eq_zero_iff'] },
    { simpa only [not_exists, not_not, eq_self_iff_true, true_iff] using h } },
  have hd_symm : ‚àÄ x y, d x y = d y x,
  { intros x y, dsimp only [d],
    simp only [@symmetric_rel.mk_mem_comm _ _ (hU_symm _) x y] },
  have hr : (1 / 2 : ‚Ñù‚â•0) ‚àà Ioo (0 : ‚Ñù‚â•0) 1,
    from ‚ü®nnreal.half_pos one_pos, nnreal.half_lt_self one_ne_zero‚ü©,
  letI := pseudo_metric_space.of_prenndist d (Œª x, hd‚ÇÄ.2 (setoid.refl _)) hd_symm, 
  have hdist_le : ‚àÄ x y, dist x y ‚â§ d x y,
    from pseudo_metric_space.dist_of_prenndist_le _ _ _,
  have hle_d : ‚àÄ {x y : X} {n : ‚Ñï}, (1 / 2) ^ n ‚â§ d x y ‚Üî (x, y) ‚àâ U n,
  { intros x y n,
    simp only [d], split_ifs with h,
    { rw [(strict_anti_pow hr.1 hr.2).le_iff_le, nat.find_le_iff],
      exact ‚ü®Œª ‚ü®m, hmn, hm‚ü© hn, hm (hB.antitone hmn hn), Œª h, ‚ü®n, le_rfl, h‚ü©‚ü© },
    { push_neg at h,
      simp only [h, not_true, (pow_pos hr.1 _).not_le] } },
  have hd_le : ‚àÄ x y, ‚Üë(d x y) ‚â§ 2 * dist x y,
  { refine pseudo_metric_space.le_two_mul_dist_of_prenndist _ _ _ (Œª x‚ÇÅ x‚ÇÇ x‚ÇÉ x‚ÇÑ, _),
    by_cases H : ‚àÉ n, (x‚ÇÅ, x‚ÇÑ) ‚àâ U n,
    { refine (dif_pos H).trans_le _,
      rw [‚Üê nnreal.div_le_iff' two_ne_zero, ‚Üê mul_one_div (_ ^ _), ‚Üê pow_succ'],
      simp only [le_max_iff, hle_d, ‚Üê not_and_distrib],
      rintro ‚ü®h‚ÇÅ‚ÇÇ, h‚ÇÇ‚ÇÉ, h‚ÇÉ‚ÇÑ‚ü©,
      refine nat.find_spec H (hU_comp (lt_add_one $ nat.find H) _),
      exact ‚ü®x‚ÇÇ, ‚ü®x‚ÇÅ, refl_mem_uniformity (hB.mem _), h‚ÇÅ‚ÇÇ‚ü©, ‚ü®x‚ÇÉ, h‚ÇÇ‚ÇÉ, h‚ÇÉ‚ÇÑ‚ü©‚ü© },
    { exact (dif_neg H).trans_le (zero_le _) } },
  refine ‚ü®infer_instance, uniform_space_eq $
    (uniformity_basis_dist_pow hr.1 hr.2).ext hB.to_has_basis _ _‚ü©,
  { refine Œª n hn, ‚ü®n, hn, Œª x hx, (hdist_le _ _).trans_lt _‚ü©,
    rwa [‚Üê nnreal.coe_pow, nnreal.coe_lt_coe, ‚Üê not_le, hle_d, not_not, prod.mk.eta] },
  { refine Œª n hn, ‚ü®n + 1, trivial, Œª x hx, _‚ü©,
    rw [mem_set_of_eq] at hx,
    contrapose! hx,
    refine le_trans _ ((div_le_iff' (@two_pos ‚Ñù _ _)).2 (hd_le x.1 x.2)),
    rwa [‚Üê nnreal.coe_two, ‚Üê nnreal.coe_div, ‚Üê nnreal.coe_pow, nnreal.coe_le_coe, pow_succ',
      mul_one_div, nnreal.div_le_iff two_ne_zero, div_mul_cancel _ (@two_ne_zero ‚Ñù‚â•0 _ _),
      hle_d, prod.mk.eta] }
end

protected noncomputable def uniform_space.pseudo_metric_space (X : Type*) [uniform_space X]
  [is_countably_generated (ùì§ X)] : pseudo_metric_space X :=
(uniform_space.metrizable_uniformity X).some.replace_uniformity $
  congr_arg _ (uniform_space.metrizable_uniformity X).some_spec.symm

protected noncomputable def uniform_space.metric_space (X : Type*) [uniform_space X]
  [is_countably_generated (ùì§ X)] [separated_space X] : metric_space X :=
@of_t2_pseudo_metric_space X (uniform_space.pseudo_metric_space X) ‚Äπ_‚Ä∫
